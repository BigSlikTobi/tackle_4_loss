# TODOs: Known Issues and Required Clean_ups

## Table of Contents
- [Task: Create Global Language Selection Control for Adaptive UI](#task-create-global-language-selection-control-for-adaptive-ui)
- [Task: Resolve Persistent 404 Asset Loading Error on Web/Desktop](#task-resolve-persistent-404-asset-loading-error-on-webdesktop)
- [Task: Implement Article Sharing Functionality](#task-implement-article-sharing-functionality)
- [Task: Fetch and Display Full Article Content on Detail Screen](#task-fetch-and-display-full-article-content-on-detail-screen)
- [Task: Implement Pagination for Team-Specific Article List](#task-implement-pagination-for-team-specific-article-list)

## Task: Create Global Language Selection Control for Adaptive UI

**Problem:**
The app uses an adaptive navigation system (`MainNavigationWrapper`):
- Mobile uses `BottomNavigationBar`.
- Desktop/Tablet uses a `Drawer` accessed via the `AppBar`.
The language selection UI (EN/DE RadioListTiles) was implemented *only* within the `Drawer`, making it unavailable on mobile. We need a consistent way for users on all platforms to access and change the language preference managed by `localeNotifierProvider`.

**Goal:**
Implement a user interface element for language selection that is:
1.  **Accessible** on both mobile and desktop layouts.
2.  **Consistent** in function.
3.  **Integrated** naturally into the UI patterns for each layout.

**Possible Approaches (Consider these or propose others):**
*   **Option A (Global Action):** Move the language picker back to the `GlobalAppBar`'s `actions` list (using a `PopupMenuButton` or similar) so it's always visible in the top bar.
*   **Option B (Conditional UI):** Keep the language picker in the `Drawer` for desktop, but add a dedicated language setting option within one of the mobile `BottomNavigationBar` tabs (e.g., inside the "More" screen).
*   **Option C (Dedicated Settings Screen):** Create a dedicated "Settings" screen accessible from both the `Drawer` (desktop) and the `BottomNavigationBar` (mobile, likely via the "More" tab) where language selection resides.

## Task: Resolve Persistent 404 Asset Loading Error on Web/Desktop

**Problem:**
When running the application, particularly after selecting a "My Team" preference which triggers updates in the `TeamHuddleSection` and its child widgets (`UpcomingGamesCard`, `InjuryReportCard`), we consistently encounter 404 errors when trying to load team logo assets.

The error message typically looks like this:
`Error while trying to load an asset: Flutter Web engine failed to fetch "assets/assets/logos/some_team_name.png". HTTP request succeeded, but the server responded with HTTP status 404.`

The key issue is the duplicated path segment **`assets/assets/`**. This indicates that somewhere in the code, the 'assets/' prefix is being added incorrectly to the already correct path generated by the `getTeamLogoPath` helper function (which returns 'assets/logos/some_team_name.png').

Despite previous attempts to fix direct `Image.asset()` calls in the relevant widgets (`TeamHuddleSection`, `UpcomingGamesCard`, `InjuryReportCard`, `TeamSelectionDropdown`), the issue persists, suggesting the problem might be more subtle or located elsewhere. The `PointerDeviceKind.trackpad` assertion error in the logs is likely unrelated but occurred concurrently.

**Goal:**
Identify and fix the root cause of the duplicated `assets/assets/` path when loading team logo images. Ensure that `Image.asset` consistently receives the correct path (e.g., `assets/logos/chicago_bears.png`) and that logos load correctly across all relevant widgets and application states, especially after selecting a team preference.

**Possible Areas to Investigate:**
*   **Re-verify `Image.asset` Calls:** Meticulously re-examine every single `Image.asset()` call that uses the `getTeamLogoPath` function in the following files (and any others potentially added):
    *   `lib/features/my_team/ui/widgets/team_huddle_section.dart`
    *   `lib/features/my_team/ui/widgets/upcoming_games_card.dart`
    *   `lib/features/my_team/ui/widgets/injury_report_card.dart`
    *   `lib/features/my_team/ui/widgets/team_selection_dropdown.dart`
    Ensure there's no string concatenation adding an extra `assets/`.
*   **`getTeamLogoPath` Function:** Double-check the return value of `getTeamLogoPath` in `lib/core/constants/team_constants.dart` to be absolutely certain it returns the correct format (`assets/logos/...`).
*   **State Management Interactions:** Could a Riverpod provider or state update interaction somehow be modifying or incorrectly passing the path string? (Less likely, but possible).
*   **Build/Cache Issues:** Although `flutter clean` was likely tried, consider if there's a more persistent web build cache issue.
*   **Underlying Widget Issues:** Is there any custom widget wrapping `Image.asset` that might be interfering with the path?

**Acceptance Criteria:**
*   Selecting a team via the "My Team" feature (or dropdown) correctly displays the team's logo in the `TeamHuddleSection`, `UpcomingGamesCard`, and `InjuryReportCard` without any 404 errors in the console.
*   The path used to load the asset in the browser's network inspector (or Flutter logs) is correctly formatted (e.g., `assets/logos/some_team_name.png`).
*   The fix does not introduce regressions in other parts of the application.

## Task: Implement Article Sharing Functionality

**Problem:**
The `ArticleDetailScreen` currently includes a placeholder "Share" icon button in its `AppBar`. Tapping this button only prints a debug message to the console (`debugPrint('Share article $articleId')`). There is no actual functionality implemented to allow users to share the displayed article with other apps or services.

**Goal:**
Implement native sharing functionality for the currently displayed article. When the user taps the share icon, the device's standard sharing dialog/sheet should appear, allowing the user to share relevant information about the article (e.g., headline and URL) to other installed applications (like messaging apps, social media, email, etc.).

**Possible Approaches & Considerations:**
*   **Use the `share_plus` Package:** This is the most common and recommended Flutter package for invoking the native platform sharing UI.
    *   Add `share_plus` to `pubspec.yaml`.
    *   In the `onPressed` callback of the share `IconButton`:
        *   Fetch necessary article details (at minimum the URL, likely also the headline). This might require accessing the article data loaded by the screen (see related TODO for data fetching).
        *   Construct the content to be shared (e.g., a string combining the headline and URL).
        *   Call `Share.share(shareContent, subject: articleHeadline);`. The `subject` is often used for email subjects.
*   **Data to Share:** Determine the best information to share. Usually, this includes:
    *   The article's headline (as the `subject` or part of the main text).
    *   The canonical URL of the article (fetched from the backend, likely stored in `SourceArticles.url`).
*   **Context/UI:** Ensure the sharing action provides appropriate feedback (e.g., the share sheet appears promptly). Consider the source rectangle for iPad sharing if using `share_plus`.

**Acceptance Criteria:**
*   Tapping the share icon in the `ArticleDetailScreen` AppBar opens the native OS sharing dialog/sheet.
*   The dialog allows sharing the article's headline and URL (or other relevant info) to compatible apps.
*   The implementation uses a standard package like `share_plus` for cross-platform compatibility.
*   Necessary article data (URL, headline) is correctly fetched and passed to the sharing function.

## Task: Fetch and Display Full Article Content on Detail Screen

**Problem:**
The `ArticleDetailScreen` currently only displays the passed `articleId` as placeholder text (`Text('Showing details for Article ID: $articleId')`). It does not fetch or render the actual full content (headline, images, body text in English/German) associated with that ID from the backend.

**Goal:**
Implement the data fetching logic and UI rendering for the `ArticleDetailScreen` to display the complete article content based on the provided `articleId`. The screen should handle loading and error states appropriately and display content according to the selected language.

**Possible Approaches & Considerations:**
*   **Backend Endpoint:** Ensure a dedicated Supabase Edge Function (or potentially a direct table query if RLS is sufficient) exists to fetch the *full* details of a single `NewsArticle` (including `ContentEnglish`, `ContentGerman`, `headlineEnglish`, `headlineGerman`, images, `createdAt`, `SourceName`, `sourceUrl`, etc.) based on its ID. This endpoint should respect RLS (only return 'PUBLISHED' articles).
*   **Data Fetching Service:** Create or update a service class (e.g., `ArticleDetailService` in `lib/features/article_detail/data/`) responsible for calling the backend endpoint. This service should take the `articleId` and return a `Future<Article>` (assuming a full `Article` model exists or needs to be created).
*   **Riverpod Provider:** Use a Riverpod provider, likely a `FutureProvider.family` or `AsyncNotifierProvider.family`, to manage the fetching state for a specific `articleId`.
    *   `FutureProvider.family<Article, int>`: Simpler for read-only display. Takes the `articleId` as an argument.
    *   `AsyncNotifierProvider.family<ArticleNotifier, Article, int>`: More flexible if you need to perform actions related to the detail screen later.
*   **UI Implementation:**
    *   Make `ArticleDetailScreen` a `ConsumerWidget` or `ConsumerStatefulWidget`.
    *   Watch the new Riverpod provider using the passed `articleId`.
    *   Use the provider's state (`.when(...)`) to display:
        *   A `LoadingIndicator` while fetching.
        *   An `ErrorMessageWidget` on error (with retry).
        *   The formatted article content on success.
*   **Content Rendering:**
    *   Display the headline (respecting the selected language via `localeNotifierProvider`).
    *   Display the main image(s) using `CachedNetworkImage`.
    *   Display the main body content (`ContentEnglish` or `ContentGerman` based on locale). **Consider using `flutter_html` or `flutter_markdown` package if the content contains HTML or Markdown formatting** that needs proper rendering, otherwise, a simple `Text` widget might suffice if it's plain text.
    *   Display metadata like publication date, source name, etc.
*   **Model:** You might need a more detailed `Article` model class (perhaps in `lib/features/article_detail/data/` or `lib/core/models/`) to represent the full structure returned by the detail endpoint, distinct from the `ArticlePreview` used in the list.

**Acceptance Criteria:**
*   When navigated to, `ArticleDetailScreen` fetches the full data for the given `articleId` from the backend.
*   Appropriate loading and error states are shown during fetching.
*   On success, the screen displays the article's headline, main image(s), and body content (respecting the selected language).
*   Relevant metadata (date, source) is displayed.
*   The implementation uses Riverpod for state management and a dedicated service for data fetching.

## Task: Implement Pagination for Team-Specific Article List

**Problem:**
The `TeamArticleList` widget (used on the "My Team" screen) currently fetches only the *first page* of articles for the selected team using a `FutureBuilder` and the `NewsFeedService.getArticlePreviews` method. It does not handle loading subsequent pages of articles if more exist for that team, nor does it provide a mechanism for infinite scrolling. Users can only see the initial batch of articles returned.

**Goal:**
Refactor `TeamArticleList` to support pagination, allowing users to continuously load more articles for their selected team as they scroll down the list. The implementation should efficiently fetch data page by page using the cursor returned by the `articlePreviews` Edge Function.

**Possible Approaches & Considerations:**
*   **Refactor to `ConsumerStatefulWidget`:** The widget needs to manage a `ScrollController` to detect when the user scrolls near the bottom and maintain the list of loaded articles and the `nextCursor` state.
*   **Use Riverpod (Recommended):** Instead of managing state locally within the widget, create a dedicated Riverpod provider, likely an `AsyncNotifierProvider.family`, to handle the paginated state specifically for a given `teamId`.
    *   **Provider Definition:** Define `teamArticlesProvider = AsyncNotifierProvider.family<TeamArticlesNotifier, List<ArticlePreview>, String>(...)`. The family argument will be the `teamId`.
    *   **Notifier Logic (`TeamArticlesNotifier`):**
        *   The `build(String teamId)` method would perform the initial fetch using `NewsFeedService.getArticlePreviews(teamId: teamId)`.
        *   Store the fetched articles, the `nextCursor`, and loading states internally.
        *   Implement a `fetchNextPage()` method similar to the one in `PaginatedArticlesNotifier` but using the stored `teamId` and cursor for subsequent calls to `getArticlePreviews`.
    *   **UI (`TeamArticleList` becomes `ConsumerWidget`):**
        *   Watch the new provider: `ref.watch(teamArticlesProvider(teamId))`.
        *   Use the `AsyncValue` state (`.when(...)`) to display loading, error, and data states.
        *   Attach a `ScrollController` to the `ListView.builder`.
        *   In the scroll listener (`_onScroll`), call `ref.read(teamArticlesProvider(teamId).notifier).fetchNextPage()`.
        *   In the `ListView.builder`, check if more data is being loaded (`teamArticlesValue is AsyncLoading && teamArticlesValue.hasValue`) and display a loading indicator at the end of the list.
*   **ScrollController:** Add a `ScrollController` and attach it to the `ListView.builder`. Add a listener to detect when the user is near the bottom (`scrollController.position.pixels >= scrollController.position.maxScrollExtent - threshold`).
*   **Loading Indicator:** Append a `LoadingIndicator` widget to the end of the list while `fetchNextPage()` is executing.
*   **Error Handling:** Ensure errors during subsequent page fetches are handled gracefully (e.g., show a message, stop trying to load more).

**Acceptance Criteria:**
*   When viewing the "My Team" screen with a selected team, the initial list of articles loads.
*   Scrolling down the list triggers fetching of the next page of articles for that specific team when the user nears the bottom.
*   New articles are appended seamlessly to the existing list.
*   A loading indicator is shown at the bottom while fetching subsequent pages.
*   Pagination stops correctly when the backend indicates no more articles are available (no `nextCursor`).
*   The implementation uses Riverpod (`AsyncNotifierProvider.family` recommended) for managing the paginated state.